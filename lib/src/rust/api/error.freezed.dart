// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$ContinuousJoinError {

 Object get field0;



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ContinuousJoinError&&const DeepCollectionEquality().equals(other.field0, field0));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(field0));

@override
String toString() {
  return 'ContinuousJoinError(field0: $field0)';
}


}

/// @nodoc
class $ContinuousJoinErrorCopyWith<$Res>  {
$ContinuousJoinErrorCopyWith(ContinuousJoinError _, $Res Function(ContinuousJoinError) __);
}


/// @nodoc


class ContinuousJoinError_HeaderParseError extends ContinuousJoinError {
  const ContinuousJoinError_HeaderParseError(this.field0): super._();
  

@override final  HeaderParseError field0;

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ContinuousJoinError_HeaderParseErrorCopyWith<ContinuousJoinError_HeaderParseError> get copyWith => _$ContinuousJoinError_HeaderParseErrorCopyWithImpl<ContinuousJoinError_HeaderParseError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ContinuousJoinError_HeaderParseError&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'ContinuousJoinError.headerParseError(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $ContinuousJoinError_HeaderParseErrorCopyWith<$Res> implements $ContinuousJoinErrorCopyWith<$Res> {
  factory $ContinuousJoinError_HeaderParseErrorCopyWith(ContinuousJoinError_HeaderParseError value, $Res Function(ContinuousJoinError_HeaderParseError) _then) = _$ContinuousJoinError_HeaderParseErrorCopyWithImpl;
@useResult
$Res call({
 HeaderParseError field0
});


$HeaderParseErrorCopyWith<$Res> get field0;

}
/// @nodoc
class _$ContinuousJoinError_HeaderParseErrorCopyWithImpl<$Res>
    implements $ContinuousJoinError_HeaderParseErrorCopyWith<$Res> {
  _$ContinuousJoinError_HeaderParseErrorCopyWithImpl(this._self, this._then);

  final ContinuousJoinError_HeaderParseError _self;
  final $Res Function(ContinuousJoinError_HeaderParseError) _then;

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(ContinuousJoinError_HeaderParseError(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as HeaderParseError,
  ));
}

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$HeaderParseErrorCopyWith<$Res> get field0 {
  
  return $HeaderParseErrorCopyWith<$Res>(_self.field0, (value) {
    return _then(_self.copyWith(field0: value));
  });
}
}

/// @nodoc


class ContinuousJoinError_JoinError extends ContinuousJoinError {
  const ContinuousJoinError_JoinError(this.field0): super._();
  

@override final  JoinError field0;

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ContinuousJoinError_JoinErrorCopyWith<ContinuousJoinError_JoinError> get copyWith => _$ContinuousJoinError_JoinErrorCopyWithImpl<ContinuousJoinError_JoinError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ContinuousJoinError_JoinError&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'ContinuousJoinError.joinError(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $ContinuousJoinError_JoinErrorCopyWith<$Res> implements $ContinuousJoinErrorCopyWith<$Res> {
  factory $ContinuousJoinError_JoinErrorCopyWith(ContinuousJoinError_JoinError value, $Res Function(ContinuousJoinError_JoinError) _then) = _$ContinuousJoinError_JoinErrorCopyWithImpl;
@useResult
$Res call({
 JoinError field0
});


$JoinErrorCopyWith<$Res> get field0;

}
/// @nodoc
class _$ContinuousJoinError_JoinErrorCopyWithImpl<$Res>
    implements $ContinuousJoinError_JoinErrorCopyWith<$Res> {
  _$ContinuousJoinError_JoinErrorCopyWithImpl(this._self, this._then);

  final ContinuousJoinError_JoinError _self;
  final $Res Function(ContinuousJoinError_JoinError) _then;

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(ContinuousJoinError_JoinError(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as JoinError,
  ));
}

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$JoinErrorCopyWith<$Res> get field0 {
  
  return $JoinErrorCopyWith<$Res>(_self.field0, (value) {
    return _then(_self.copyWith(field0: value));
  });
}
}

/// @nodoc


class ContinuousJoinError_DecodeError extends ContinuousJoinError {
  const ContinuousJoinError_DecodeError(this.field0): super._();
  

@override final  DecodeError field0;

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ContinuousJoinError_DecodeErrorCopyWith<ContinuousJoinError_DecodeError> get copyWith => _$ContinuousJoinError_DecodeErrorCopyWithImpl<ContinuousJoinError_DecodeError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ContinuousJoinError_DecodeError&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'ContinuousJoinError.decodeError(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $ContinuousJoinError_DecodeErrorCopyWith<$Res> implements $ContinuousJoinErrorCopyWith<$Res> {
  factory $ContinuousJoinError_DecodeErrorCopyWith(ContinuousJoinError_DecodeError value, $Res Function(ContinuousJoinError_DecodeError) _then) = _$ContinuousJoinError_DecodeErrorCopyWithImpl;
@useResult
$Res call({
 DecodeError field0
});


$DecodeErrorCopyWith<$Res> get field0;

}
/// @nodoc
class _$ContinuousJoinError_DecodeErrorCopyWithImpl<$Res>
    implements $ContinuousJoinError_DecodeErrorCopyWith<$Res> {
  _$ContinuousJoinError_DecodeErrorCopyWithImpl(this._self, this._then);

  final ContinuousJoinError_DecodeError _self;
  final $Res Function(ContinuousJoinError_DecodeError) _then;

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(ContinuousJoinError_DecodeError(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as DecodeError,
  ));
}

/// Create a copy of ContinuousJoinError
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DecodeErrorCopyWith<$Res> get field0 {
  
  return $DecodeErrorCopyWith<$Res>(_self.field0, (value) {
    return _then(_self.copyWith(field0: value));
  });
}
}

/// @nodoc
mixin _$DecodeError {

 Object get field0;



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DecodeError&&const DeepCollectionEquality().equals(other.field0, field0));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(field0));

@override
String toString() {
  return 'DecodeError(field0: $field0)';
}


}

/// @nodoc
class $DecodeErrorCopyWith<$Res>  {
$DecodeErrorCopyWith(DecodeError _, $Res Function(DecodeError) __);
}


/// @nodoc


class DecodeError_UnableToDecodeHex extends DecodeError {
  const DecodeError_UnableToDecodeHex(this.field0, this.field1): super._();
  

@override final  BigInt field0;
 final  String field1;

/// Create a copy of DecodeError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DecodeError_UnableToDecodeHexCopyWith<DecodeError_UnableToDecodeHex> get copyWith => _$DecodeError_UnableToDecodeHexCopyWithImpl<DecodeError_UnableToDecodeHex>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DecodeError_UnableToDecodeHex&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1);

@override
String toString() {
  return 'DecodeError.unableToDecodeHex(field0: $field0, field1: $field1)';
}


}

/// @nodoc
abstract mixin class $DecodeError_UnableToDecodeHexCopyWith<$Res> implements $DecodeErrorCopyWith<$Res> {
  factory $DecodeError_UnableToDecodeHexCopyWith(DecodeError_UnableToDecodeHex value, $Res Function(DecodeError_UnableToDecodeHex) _then) = _$DecodeError_UnableToDecodeHexCopyWithImpl;
@useResult
$Res call({
 BigInt field0, String field1
});




}
/// @nodoc
class _$DecodeError_UnableToDecodeHexCopyWithImpl<$Res>
    implements $DecodeError_UnableToDecodeHexCopyWith<$Res> {
  _$DecodeError_UnableToDecodeHexCopyWithImpl(this._self, this._then);

  final DecodeError_UnableToDecodeHex _self;
  final $Res Function(DecodeError_UnableToDecodeHex) _then;

/// Create a copy of DecodeError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,Object? field1 = null,}) {
  return _then(DecodeError_UnableToDecodeHex(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as BigInt,null == field1 ? _self.field1 : field1 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class DecodeError_UnableToDecodeBase32 extends DecodeError {
  const DecodeError_UnableToDecodeBase32(this.field0, this.field1): super._();
  

@override final  BigInt field0;
 final  String field1;

/// Create a copy of DecodeError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DecodeError_UnableToDecodeBase32CopyWith<DecodeError_UnableToDecodeBase32> get copyWith => _$DecodeError_UnableToDecodeBase32CopyWithImpl<DecodeError_UnableToDecodeBase32>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DecodeError_UnableToDecodeBase32&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1);

@override
String toString() {
  return 'DecodeError.unableToDecodeBase32(field0: $field0, field1: $field1)';
}


}

/// @nodoc
abstract mixin class $DecodeError_UnableToDecodeBase32CopyWith<$Res> implements $DecodeErrorCopyWith<$Res> {
  factory $DecodeError_UnableToDecodeBase32CopyWith(DecodeError_UnableToDecodeBase32 value, $Res Function(DecodeError_UnableToDecodeBase32) _then) = _$DecodeError_UnableToDecodeBase32CopyWithImpl;
@useResult
$Res call({
 BigInt field0, String field1
});




}
/// @nodoc
class _$DecodeError_UnableToDecodeBase32CopyWithImpl<$Res>
    implements $DecodeError_UnableToDecodeBase32CopyWith<$Res> {
  _$DecodeError_UnableToDecodeBase32CopyWithImpl(this._self, this._then);

  final DecodeError_UnableToDecodeBase32 _self;
  final $Res Function(DecodeError_UnableToDecodeBase32) _then;

/// Create a copy of DecodeError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,Object? field1 = null,}) {
  return _then(DecodeError_UnableToDecodeBase32(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as BigInt,null == field1 ? _self.field1 : field1 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class DecodeError_UnableToInflateZlib extends DecodeError {
  const DecodeError_UnableToInflateZlib(this.field0): super._();
  

@override final  String field0;

/// Create a copy of DecodeError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DecodeError_UnableToInflateZlibCopyWith<DecodeError_UnableToInflateZlib> get copyWith => _$DecodeError_UnableToInflateZlibCopyWithImpl<DecodeError_UnableToInflateZlib>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DecodeError_UnableToInflateZlib&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'DecodeError.unableToInflateZlib(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $DecodeError_UnableToInflateZlibCopyWith<$Res> implements $DecodeErrorCopyWith<$Res> {
  factory $DecodeError_UnableToInflateZlibCopyWith(DecodeError_UnableToInflateZlib value, $Res Function(DecodeError_UnableToInflateZlib) _then) = _$DecodeError_UnableToInflateZlibCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$DecodeError_UnableToInflateZlibCopyWithImpl<$Res>
    implements $DecodeError_UnableToInflateZlibCopyWith<$Res> {
  _$DecodeError_UnableToInflateZlibCopyWithImpl(this._self, this._then);

  final DecodeError_UnableToInflateZlib _self;
  final $Res Function(DecodeError_UnableToInflateZlib) _then;

/// Create a copy of DecodeError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(DecodeError_UnableToInflateZlib(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$HeaderParseError {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HeaderParseError);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'HeaderParseError()';
}


}

/// @nodoc
class $HeaderParseErrorCopyWith<$Res>  {
$HeaderParseErrorCopyWith(HeaderParseError _, $Res Function(HeaderParseError) __);
}


/// @nodoc


class HeaderParseError_Empty extends HeaderParseError {
  const HeaderParseError_Empty(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HeaderParseError_Empty);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'HeaderParseError.empty()';
}


}




/// @nodoc


class HeaderParseError_InvalidEncoding extends HeaderParseError {
  const HeaderParseError_InvalidEncoding(this.field0): super._();
  

 final  String field0;

/// Create a copy of HeaderParseError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HeaderParseError_InvalidEncodingCopyWith<HeaderParseError_InvalidEncoding> get copyWith => _$HeaderParseError_InvalidEncodingCopyWithImpl<HeaderParseError_InvalidEncoding>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HeaderParseError_InvalidEncoding&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'HeaderParseError.invalidEncoding(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $HeaderParseError_InvalidEncodingCopyWith<$Res> implements $HeaderParseErrorCopyWith<$Res> {
  factory $HeaderParseError_InvalidEncodingCopyWith(HeaderParseError_InvalidEncoding value, $Res Function(HeaderParseError_InvalidEncoding) _then) = _$HeaderParseError_InvalidEncodingCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$HeaderParseError_InvalidEncodingCopyWithImpl<$Res>
    implements $HeaderParseError_InvalidEncodingCopyWith<$Res> {
  _$HeaderParseError_InvalidEncodingCopyWithImpl(this._self, this._then);

  final HeaderParseError_InvalidEncoding _self;
  final $Res Function(HeaderParseError_InvalidEncoding) _then;

/// Create a copy of HeaderParseError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(HeaderParseError_InvalidEncoding(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class HeaderParseError_InvalidFileType extends HeaderParseError {
  const HeaderParseError_InvalidFileType(this.field0): super._();
  

 final  String field0;

/// Create a copy of HeaderParseError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HeaderParseError_InvalidFileTypeCopyWith<HeaderParseError_InvalidFileType> get copyWith => _$HeaderParseError_InvalidFileTypeCopyWithImpl<HeaderParseError_InvalidFileType>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HeaderParseError_InvalidFileType&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'HeaderParseError.invalidFileType(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $HeaderParseError_InvalidFileTypeCopyWith<$Res> implements $HeaderParseErrorCopyWith<$Res> {
  factory $HeaderParseError_InvalidFileTypeCopyWith(HeaderParseError_InvalidFileType value, $Res Function(HeaderParseError_InvalidFileType) _then) = _$HeaderParseError_InvalidFileTypeCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$HeaderParseError_InvalidFileTypeCopyWithImpl<$Res>
    implements $HeaderParseError_InvalidFileTypeCopyWith<$Res> {
  _$HeaderParseError_InvalidFileTypeCopyWithImpl(this._self, this._then);

  final HeaderParseError_InvalidFileType _self;
  final $Res Function(HeaderParseError_InvalidFileType) _then;

/// Create a copy of HeaderParseError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(HeaderParseError_InvalidFileType(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class HeaderParseError_InvalidFixedHeader extends HeaderParseError {
  const HeaderParseError_InvalidFixedHeader(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HeaderParseError_InvalidFixedHeader);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'HeaderParseError.invalidFixedHeader()';
}


}




/// @nodoc


class HeaderParseError_InvalidHeaderSize extends HeaderParseError {
  const HeaderParseError_InvalidHeaderSize(this.field0): super._();
  

 final  BigInt field0;

/// Create a copy of HeaderParseError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HeaderParseError_InvalidHeaderSizeCopyWith<HeaderParseError_InvalidHeaderSize> get copyWith => _$HeaderParseError_InvalidHeaderSizeCopyWithImpl<HeaderParseError_InvalidHeaderSize>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HeaderParseError_InvalidHeaderSize&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'HeaderParseError.invalidHeaderSize(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $HeaderParseError_InvalidHeaderSizeCopyWith<$Res> implements $HeaderParseErrorCopyWith<$Res> {
  factory $HeaderParseError_InvalidHeaderSizeCopyWith(HeaderParseError_InvalidHeaderSize value, $Res Function(HeaderParseError_InvalidHeaderSize) _then) = _$HeaderParseError_InvalidHeaderSizeCopyWithImpl;
@useResult
$Res call({
 BigInt field0
});




}
/// @nodoc
class _$HeaderParseError_InvalidHeaderSizeCopyWithImpl<$Res>
    implements $HeaderParseError_InvalidHeaderSizeCopyWith<$Res> {
  _$HeaderParseError_InvalidHeaderSizeCopyWithImpl(this._self, this._then);

  final HeaderParseError_InvalidHeaderSize _self;
  final $Res Function(HeaderParseError_InvalidHeaderSize) _then;

/// Create a copy of HeaderParseError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(HeaderParseError_InvalidHeaderSize(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as BigInt,
  ));
}


}

/// @nodoc


class HeaderParseError_InvalidHeaderParts extends HeaderParseError {
  const HeaderParseError_InvalidHeaderParts(this.field0): super._();
  

 final  String field0;

/// Create a copy of HeaderParseError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HeaderParseError_InvalidHeaderPartsCopyWith<HeaderParseError_InvalidHeaderParts> get copyWith => _$HeaderParseError_InvalidHeaderPartsCopyWithImpl<HeaderParseError_InvalidHeaderParts>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HeaderParseError_InvalidHeaderParts&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'HeaderParseError.invalidHeaderParts(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $HeaderParseError_InvalidHeaderPartsCopyWith<$Res> implements $HeaderParseErrorCopyWith<$Res> {
  factory $HeaderParseError_InvalidHeaderPartsCopyWith(HeaderParseError_InvalidHeaderParts value, $Res Function(HeaderParseError_InvalidHeaderParts) _then) = _$HeaderParseError_InvalidHeaderPartsCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$HeaderParseError_InvalidHeaderPartsCopyWithImpl<$Res>
    implements $HeaderParseError_InvalidHeaderPartsCopyWith<$Res> {
  _$HeaderParseError_InvalidHeaderPartsCopyWithImpl(this._self, this._then);

  final HeaderParseError_InvalidHeaderParts _self;
  final $Res Function(HeaderParseError_InvalidHeaderParts) _then;

/// Create a copy of HeaderParseError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(HeaderParseError_InvalidHeaderParts(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$JoinError {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'JoinError()';
}


}

/// @nodoc
class $JoinErrorCopyWith<$Res>  {
$JoinErrorCopyWith(JoinError _, $Res Function(JoinError) __);
}


/// @nodoc


class JoinError_Empty extends JoinError {
  const JoinError_Empty(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError_Empty);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'JoinError.empty()';
}


}




/// @nodoc


class JoinError_ConflictingHeaders extends JoinError {
  const JoinError_ConflictingHeaders(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError_ConflictingHeaders);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'JoinError.conflictingHeaders()';
}


}




/// @nodoc


class JoinError_TooManyParts extends JoinError {
  const JoinError_TooManyParts(this.field0, this.field1): super._();
  

 final  BigInt field0;
 final  BigInt field1;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$JoinError_TooManyPartsCopyWith<JoinError_TooManyParts> get copyWith => _$JoinError_TooManyPartsCopyWithImpl<JoinError_TooManyParts>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError_TooManyParts&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1);

@override
String toString() {
  return 'JoinError.tooManyParts(field0: $field0, field1: $field1)';
}


}

/// @nodoc
abstract mixin class $JoinError_TooManyPartsCopyWith<$Res> implements $JoinErrorCopyWith<$Res> {
  factory $JoinError_TooManyPartsCopyWith(JoinError_TooManyParts value, $Res Function(JoinError_TooManyParts) _then) = _$JoinError_TooManyPartsCopyWithImpl;
@useResult
$Res call({
 BigInt field0, BigInt field1
});




}
/// @nodoc
class _$JoinError_TooManyPartsCopyWithImpl<$Res>
    implements $JoinError_TooManyPartsCopyWith<$Res> {
  _$JoinError_TooManyPartsCopyWithImpl(this._self, this._then);

  final JoinError_TooManyParts _self;
  final $Res Function(JoinError_TooManyParts) _then;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,Object? field1 = null,}) {
  return _then(JoinError_TooManyParts(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as BigInt,null == field1 ? _self.field1 : field1 // ignore: cast_nullable_to_non_nullable
as BigInt,
  ));
}


}

/// @nodoc


class JoinError_DuplicatePartWrongContent extends JoinError {
  const JoinError_DuplicatePartWrongContent(this.field0): super._();
  

 final  BigInt field0;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$JoinError_DuplicatePartWrongContentCopyWith<JoinError_DuplicatePartWrongContent> get copyWith => _$JoinError_DuplicatePartWrongContentCopyWithImpl<JoinError_DuplicatePartWrongContent>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError_DuplicatePartWrongContent&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'JoinError.duplicatePartWrongContent(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $JoinError_DuplicatePartWrongContentCopyWith<$Res> implements $JoinErrorCopyWith<$Res> {
  factory $JoinError_DuplicatePartWrongContentCopyWith(JoinError_DuplicatePartWrongContent value, $Res Function(JoinError_DuplicatePartWrongContent) _then) = _$JoinError_DuplicatePartWrongContentCopyWithImpl;
@useResult
$Res call({
 BigInt field0
});




}
/// @nodoc
class _$JoinError_DuplicatePartWrongContentCopyWithImpl<$Res>
    implements $JoinError_DuplicatePartWrongContentCopyWith<$Res> {
  _$JoinError_DuplicatePartWrongContentCopyWithImpl(this._self, this._then);

  final JoinError_DuplicatePartWrongContent _self;
  final $Res Function(JoinError_DuplicatePartWrongContent) _then;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(JoinError_DuplicatePartWrongContent(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as BigInt,
  ));
}


}

/// @nodoc


class JoinError_PartWithNoData extends JoinError {
  const JoinError_PartWithNoData(this.field0): super._();
  

 final  BigInt field0;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$JoinError_PartWithNoDataCopyWith<JoinError_PartWithNoData> get copyWith => _$JoinError_PartWithNoDataCopyWithImpl<JoinError_PartWithNoData>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError_PartWithNoData&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'JoinError.partWithNoData(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $JoinError_PartWithNoDataCopyWith<$Res> implements $JoinErrorCopyWith<$Res> {
  factory $JoinError_PartWithNoDataCopyWith(JoinError_PartWithNoData value, $Res Function(JoinError_PartWithNoData) _then) = _$JoinError_PartWithNoDataCopyWithImpl;
@useResult
$Res call({
 BigInt field0
});




}
/// @nodoc
class _$JoinError_PartWithNoDataCopyWithImpl<$Res>
    implements $JoinError_PartWithNoDataCopyWith<$Res> {
  _$JoinError_PartWithNoDataCopyWithImpl(this._self, this._then);

  final JoinError_PartWithNoData _self;
  final $Res Function(JoinError_PartWithNoData) _then;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(JoinError_PartWithNoData(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as BigInt,
  ));
}


}

/// @nodoc


class JoinError_MissingPart extends JoinError {
  const JoinError_MissingPart(this.field0): super._();
  

 final  BigInt field0;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$JoinError_MissingPartCopyWith<JoinError_MissingPart> get copyWith => _$JoinError_MissingPartCopyWithImpl<JoinError_MissingPart>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError_MissingPart&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'JoinError.missingPart(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $JoinError_MissingPartCopyWith<$Res> implements $JoinErrorCopyWith<$Res> {
  factory $JoinError_MissingPartCopyWith(JoinError_MissingPart value, $Res Function(JoinError_MissingPart) _then) = _$JoinError_MissingPartCopyWithImpl;
@useResult
$Res call({
 BigInt field0
});




}
/// @nodoc
class _$JoinError_MissingPartCopyWithImpl<$Res>
    implements $JoinError_MissingPartCopyWith<$Res> {
  _$JoinError_MissingPartCopyWithImpl(this._self, this._then);

  final JoinError_MissingPart _self;
  final $Res Function(JoinError_MissingPart) _then;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(JoinError_MissingPart(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as BigInt,
  ));
}


}

/// @nodoc


class JoinError_HeaderParseError extends JoinError {
  const JoinError_HeaderParseError(this.field0): super._();
  

 final  HeaderParseError field0;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$JoinError_HeaderParseErrorCopyWith<JoinError_HeaderParseError> get copyWith => _$JoinError_HeaderParseErrorCopyWithImpl<JoinError_HeaderParseError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError_HeaderParseError&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'JoinError.headerParseError(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $JoinError_HeaderParseErrorCopyWith<$Res> implements $JoinErrorCopyWith<$Res> {
  factory $JoinError_HeaderParseErrorCopyWith(JoinError_HeaderParseError value, $Res Function(JoinError_HeaderParseError) _then) = _$JoinError_HeaderParseErrorCopyWithImpl;
@useResult
$Res call({
 HeaderParseError field0
});


$HeaderParseErrorCopyWith<$Res> get field0;

}
/// @nodoc
class _$JoinError_HeaderParseErrorCopyWithImpl<$Res>
    implements $JoinError_HeaderParseErrorCopyWith<$Res> {
  _$JoinError_HeaderParseErrorCopyWithImpl(this._self, this._then);

  final JoinError_HeaderParseError _self;
  final $Res Function(JoinError_HeaderParseError) _then;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(JoinError_HeaderParseError(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as HeaderParseError,
  ));
}

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$HeaderParseErrorCopyWith<$Res> get field0 {
  
  return $HeaderParseErrorCopyWith<$Res>(_self.field0, (value) {
    return _then(_self.copyWith(field0: value));
  });
}
}

/// @nodoc


class JoinError_DecodeError extends JoinError {
  const JoinError_DecodeError(this.field0): super._();
  

 final  DecodeError field0;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$JoinError_DecodeErrorCopyWith<JoinError_DecodeError> get copyWith => _$JoinError_DecodeErrorCopyWithImpl<JoinError_DecodeError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is JoinError_DecodeError&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'JoinError.decodeError(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $JoinError_DecodeErrorCopyWith<$Res> implements $JoinErrorCopyWith<$Res> {
  factory $JoinError_DecodeErrorCopyWith(JoinError_DecodeError value, $Res Function(JoinError_DecodeError) _then) = _$JoinError_DecodeErrorCopyWithImpl;
@useResult
$Res call({
 DecodeError field0
});


$DecodeErrorCopyWith<$Res> get field0;

}
/// @nodoc
class _$JoinError_DecodeErrorCopyWithImpl<$Res>
    implements $JoinError_DecodeErrorCopyWith<$Res> {
  _$JoinError_DecodeErrorCopyWithImpl(this._self, this._then);

  final JoinError_DecodeError _self;
  final $Res Function(JoinError_DecodeError) _then;

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(JoinError_DecodeError(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as DecodeError,
  ));
}

/// Create a copy of JoinError
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DecodeErrorCopyWith<$Res> get field0 {
  
  return $DecodeErrorCopyWith<$Res>(_self.field0, (value) {
    return _then(_self.copyWith(field0: value));
  });
}
}

// dart format on
